import React, { createContext, useContext, useState, useCallback, useEffect, useRef } from 'react'
import { requestRemoteSigning } from './crypto/signing'
import { riskEngine } from './riskIntelligence'
import { pythOracle, AssetSymbol } from './oracleReal'

const CATEContext = createContext(null)

export function useCATE() {
  const context = useContext(CATEContext)
  if (!context) throw new Error('useCATE must be used within CATEProvider')
  return context
}

// Simulador de volatilidade - mantém histórico entre chamadas
function createVolatilityTracker() {
  const prices = []
  const maxHistory = 20

  return {
    addPrice(price) {
      prices.push(price)
      if (prices.length > maxHistory) prices.shift()
    },
    getVolatility() {
      if (prices.length < 5) return 0
      const mean = prices.reduce((a, b) => a + b, 0) / prices.length
      const squaredDiffs = prices.map(p => Math.pow(p - mean, 2))
      const variance = squaredDiffs.reduce((a, b) => a + b, 0) / prices.length
      const stdDev = Math.sqrt(variance)
      return parseFloat(((stdDev / mean) * 100).toFixed(2))
    },
    getCount() {
      return prices.length
    },
    reset() {
      prices.length = 0
    }
  }
}

export function CATEProvider({ children }) {
  const [isRunning, setIsRunning] = useState(false)
  const [isLoading, setIsLoading] = useState(false)
  const [lastUpdate, setLastUpdate] = useState(null)
  const [signerKey, setSignerKey] = useState(null)
  const [lastDecision, setLastDecision] = useState(null)
  
  // NOVO: Estado para token selecionado
  const [selectedAsset, setSelectedAsset] = useState<AssetSymbol>('SOL')

  // useRef para manter o tracker entre renders
  const volTrackerRef = useRef(null)

  // Inicializa o tracker uma vez
  if (!volTrackerRef.current) {
    volTrackerRef.current = createVolatilityTracker()
  }

  const intervalRef = useRef(null)

  useEffect(() => {
    fetch('http://localhost:3001/health')
      .then(r => r.json())
      .then(data => setSignerKey(data.publicKey))
      .catch(console.error)
  }, [])

  const startEngine = useCallback(() => {
    setIsRunning(true)
    setIsLoading(true)
    intervalRef.current = setInterval(() => {
      setLastUpdate(new Date().toLocaleTimeString())
    }, 3000)
    setTimeout(() => setIsLoading(false), 1000)
  }, [])

  const stopEngine = useCallback(() => {
    setIsRunning(false)
    if (intervalRef.current) clearInterval(intervalRef.current)
    setLastDecision(null)
    // Não reseta o volTracker para manter histórico
  }, [])

  // NOVO: Função para trocar token e resetar tracker
  const changeAsset = useCallback((asset: AssetSymbol) => {
    setSelectedAsset(asset)
    volTrackerRef.current?.reset() // Reset volatilidade ao trocar token
    setLastDecision(null)
    console.log(`[CATE] Token changed to ${asset}`)
  }, [])

  const evaluateAndSign = useCallback(async () => {
    try {
      // Busca dados REAIS da Pyth Network com token selecionado
      console.log(`[CATE] Fetching ${selectedAsset} from Pyth...`)
      const priceData = await pythOracle.getPrice(selectedAsset)
      
      const price = priceData.price
      const confidenceRatio = (priceData.confidence / priceData.price) * 100

      // Adiciona ao tracker (persistente!)
      volTrackerRef.current.addPrice(price)
      const volatility = volTrackerRef.current.getVolatility()
      const count = volTrackerRef.current.getCount()

      console.log(`[CATE] Pyth Real - ${selectedAsset}: $${price.toFixed(2)} | Confidence: ${confidenceRatio.toFixed(2)}% | Vol: ${volatility}%`)

      const snapshot = {
        price: {
          id: `${selectedAsset}/USD`,
          price: price,
          confidenceRatio: confidenceRatio,
          publishTime: priceData.publishTime,
          numPublishers: 5,
        },
        volatility: {
          current: volatility,
          history: count,
          regime: volatility < 2 ? 'low' : volatility < 5 ? 'medium' : 'high'
        },
        circuitBreaker: {
          isOpen: false,
          reason: ''
        }
      }

      // Chama risk engine
      const decision = riskEngine.evaluate(snapshot)
      
      // Se for BLOCK, não tenta assinar
      if (decision.action === 'BLOCK') {
        setLastDecision({
          ...decision,
          timestamp: new Date().toISOString(),
          signed: false
        })
        return
      }

      // Solicita assinatura ao backend
      const signPayload = {
        assetId: `${selectedAsset}/USD`,
        price: price,
        timestamp: Math.floor(Date.now() / 1000),
        confidenceRatio: Math.floor(confidenceRatio * 100),
        riskScore: decision.riskScore,
        isBlocked: decision.action === 'BLOCK',
        publisherCount: 5,
        nonce: Math.floor(Math.random() * 1000000)
      }

      const signed = await requestRemoteSigning(signPayload)
      
      setLastDecision({
        ...decision,
        signature: signed.signature,
        timestamp: new Date().toISOString(),
        signed: true
      })

    } catch (error) {
      console.error('[CATE] Evaluation error:', error)
      setLastDecision({
        action: 'BLOCK',
        explanation: 'Error: ' + error.message,
        riskScore: 100,
        timestamp: new Date().toISOString(),
        signed: false
      })
    }
  }, [selectedAsset])

  const value = {
    isRunning,
    isLoading,
    lastUpdate,
    signerKey,
    lastDecision,
    selectedAsset,      // NOVO: expor token selecionado
    changeAsset,        // NOVO: função para trocar token
    startEngine,
    stopEngine,
    evaluateAndSign
  }

  return (
    <CATEContext.Provider value={value}>
      {children}
    </CATEContext.Provider>
  )
}
